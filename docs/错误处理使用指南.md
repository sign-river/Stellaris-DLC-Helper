# 错误处理使用指南

## 概述

项目现在使用统一的错误处理模块 `error_handler.py`，确保所有错误同时记录到：
1. **GUI操作日志** - 用户界面可见的简短错误信息
2. **标准日志文件** - `Stellaris_DLC_Cache/logs/stellaris_dlc_helper.log`
3. **错误日志文件** - `Stellaris_DLC_Cache/logs/errors.log`（包含完整堆栈跟踪）

## 快速开始

### 1. 导入错误处理器

```python
from ..utils import handle_error, handle_warning, safe_execute
```

### 2. 基本用法

#### 处理错误（推荐）

```python
try:
    # 可能出错的代码
    result = risky_operation()
except Exception as e:
    # 统一错误处理：同时记录到GUI和文件日志
    handle_error("操作失败", exc=e)
```

#### 处理警告

```python
try:
    # 可能出现警告的代码
    result = operation_with_warning()
except SomeWarning as w:
    handle_warning(f"警告: {w}")
```

#### 安全执行（自动错误处理）

```python
# 自动捕获异常并处理
result = safe_execute(
    lambda: risky_operation(),
    error_message="执行操作失败",
    return_on_error=None  # 发生错误时的返回值
)
```

### 3. 高级用法

#### 自定义错误处理器

```python
from ..utils import ErrorHandler

# 创建自定义错误处理器
error_handler = ErrorHandler(gui_logger=self.logger)

# 处理错误，控制是否显示在GUI
error_handler.handle_error(
    message="自定义错误消息",
    exc=exception_object,
    show_in_gui=True,  # 是否在GUI中显示
    log_traceback=True  # 是否记录完整堆栈
)
```

## 迁移指南

### 旧代码模式

```python
try:
    do_something()
except Exception as e:
    self.logger.error(f"操作失败: {e}")
    logging.error(f"操作失败: {e}")
```

### 新代码模式（推荐）

```python
try:
    do_something()
except Exception as e:
    handle_error("操作失败", exc=e)
```

## 错误日志文件位置

- **标准日志**: `Stellaris_DLC_Cache/logs/stellaris_dlc_helper.log`
- **错误日志**: `Stellaris_DLC_Cache/logs/errors.log`
- **操作日志**: `Stellaris_DLC_Cache/operation_logs/`

## 最佳实践

1. **使用描述性错误消息**: 清楚说明发生了什么错误
   ```python
   handle_error("下载DLC文件失败", exc=e)  # 好
   handle_error("错误", exc=e)  # 不好
   ```

2. **传递异常对象**: 确保记录完整的堆栈跟踪
   ```python
   handle_error("操作失败", exc=e)  # 好
   handle_error("操作失败")  # 不好（缺少堆栈信息）
   ```

3. **关键操作使用safe_execute**: 避免重复的try-except
   ```python
   result = safe_execute(
       lambda: critical_operation(),
       error_message="关键操作失败",
       return_on_error=default_value
   )
   ```

4. **区分错误和警告**:
   - 使用 `handle_error` 处理真正的错误（操作失败）
   - 使用 `handle_warning` 处理警告（操作继续但有问题）

## 示例场景

### 场景1: 下载文件失败

```python
def download_file(self, url, path):
    try:
        response = requests.get(url, timeout=30)
        response.raise_for_status()
        with open(path, 'wb') as f:
            f.write(response.content)
        return True
    except Exception as e:
        handle_error(f"下载文件失败: {url}", exc=e)
        return False
```

### 场景2: 安装DLC失败

```python
def install_dlc(self, dlc_id):
    try:
        # 安装逻辑
        self.install_to_game(dlc_id)
        self.logger.success(f"成功安装DLC: {dlc_id}")
        return True
    except Exception as e:
        handle_error(f"安装DLC失败: {dlc_id}", exc=e)
        return False
```

### 场景3: 批量操作

```python
def batch_download(self, dlc_list):
    success_count = 0
    fail_count = 0
    
    for dlc in dlc_list:
        result = safe_execute(
            lambda: self.download_dlc(dlc),
            error_message=f"下载{dlc['name']}失败",
            return_on_error=False
        )
        
        if result:
            success_count += 1
        else:
            fail_count += 1
    
    self.logger.info(f"批量下载完成: 成功{success_count}个，失败{fail_count}个")
```

## 注意事项

1. 错误处理器会自动初始化，无需手动创建
2. GUI日志记录器会在主窗口初始化时自动设置
3. 错误日志文件会自动创建和轮转，无需担心文件大小
4. 所有错误都会同时出现在GUI和文件日志中，方便调试

## 调试技巧

1. **查看完整错误**: 打开 `errors.log` 查看完整堆栈跟踪
2. **过滤错误**: 使用文本编辑器搜索错误日志中的特定时间或关键字
3. **GUI日志**: 用户可以直接在操作日志区域看到简短错误信息
